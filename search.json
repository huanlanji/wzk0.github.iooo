[{"title":"Git笔记","url":"/2021/11/05/git/","content":"Git介绍\nGit是分布式版本控制系统\n集中式VS分布式，SVN VS Git\nSVN和Git主要的区别在于历史版本维护的位置\nGit本地仓库包含代码库还有历史库，在本地的环境开发就可以记录历史而SVN的历史库存在于中央仓库，每次对比与提交代码都必须连接到中央仓库才能进行。\n这样的好处在于：\n自己可以在脱机环境查看开发的版本历史。\n多人开发时如果充当中央仓库的Git仓库挂了，可以随时创建一个新的中央仓库然后同步就立刻恢复了中央库。Git命令Git配置git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;email@example.com&quot;\ngit config命令的--global参数，表明这台机器上的所有Git仓库都会使用这个配置，也可以对某个仓库指定不同的用户名和邮箱地址。\n\n\n\n\n\n创建版本库初始化一个Git仓库git init\n添加文件到Git仓库包括两步：\ngit add &lt;file&gt;git commit -m &quot;description&quot;\ngit add可以反复多次使用，添加多个文件，git commit可以一次提交很多文件，-m后面输入的是本次提交的说明，可以输入任意内容。\n查看工作区状态git status\n查看修改内容git diff\ngit diff --cached\ngit diff HEAD -- &lt;file&gt;\n\ngit diff 可以查看工作区(work dict)和暂存区(stage)的区别\ngit diff --cached 可以查看暂存区(stage)和分支(master)的区别\ngit diff HEAD -- &lt;file&gt; 可以查看工作区和版本库里面最新版本的区别查看提交日志git log\n简化日志输出信息git log --pretty=oneline\n查看命令历史git reflog\n版本回退git reset --hard HEAD^\n以上命令是返回上一个版本，在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本是HEAD^^，往上100个版本写成HEAD~100。回退指定版本号git reset --hard commit_id\ncommit_id是版本号，是一个用SHA1计算出的序列\n\n工作区、暂存区和版本库工作区：在电脑里能看到的目录；版本库：在工作区有一个隐藏目录.git，是Git的版本库。Git的版本库中存了很多东西，其中最重要的就是称为stage（或者称为index）的暂存区，还有Git自动创建的master，以及指向master的指针HEAD。\n进一步解释一些命令：\n\ngit add实际上是把文件添加到暂存区\ngit commit实际上是把暂存区的所有内容提交到当前分支撤销修改丢弃工作区的修改git checkout -- &lt;file&gt;\n该命令是指将文件在工作区的修改全部撤销，这里有两种情况：\n\n\n一种是file自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；\n一种是file已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。\n\n总之，就是让这个文件回到最近一次git commit或git add时的状态。\n丢弃暂存区的修改分两步：第一步，把暂存区的修改撤销掉(unstage)，重新放回工作区：\ngit reset HEAD &lt;file&gt;\n第二步，撤销工作区的修改\ngit checkout -- &lt;file&gt;\n小结：\n\n当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- &lt;file&gt;。\n当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了第一步，第二步按第一步操作。\n已经提交了不合适的修改到版本库时，想要撤销本次提交，进行版本回退，前提是没有推送到远程库。\n\n删除文件git rm &lt;file&gt;\ngit rm &lt;file&gt;相当于执行\nrm &lt;file&gt;git add &lt;file&gt;\n进一步的解释Q：比如执行了rm text.txt 误删了怎么恢复？A：执行git checkout -- text.txt 把版本库的东西重新写回工作区就行了Q：如果执行了git rm text.txt我们会发现工作区的text.txt也删除了，怎么恢复？A：先撤销暂存区修改，重新放回工作区，然后再从版本库写回到工作区\ngit reset head text.txtgit checkout -- text.txt\nQ：如果真的想从版本库里面删除文件怎么做？A：执行git commit -m &quot;delete text.txt&quot;，提交后最新的版本库将不包含这个文件\n远程仓库创建SSH Keyssh-keygen -t rsa -C &quot;youremail@example.com&quot;\n关联远程仓库git remote add origin https://github.com/username/repositoryname.git\n推送到远程仓库git push -u origin master\n-u 表示第一次推送master分支的所有内容，此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改。\n从远程克隆git clone https://github.com/usern/repositoryname.git\n\n分支创建分支git branch &lt;branchname&gt;\n查看分支git branch\ngit branch命令会列出所有分支，当前分支前面会标一个*号。\n切换分支git checkout &lt;branchname&gt;\n\n创建+切换分支git checkout -b &lt;branchname&gt;\n\n合并某分支到当前分支git merge &lt;branchname&gt;\n\n删除分支git branch -d &lt;branchname&gt;\n查看分支合并图git log --graph\n当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。用git log --graph命令可以看到分支合并图。\n普通模式合并分支git merge --no-ff -m &quot;description&quot; &lt;branchname&gt;\n因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。合并分支时，加上--no-ff参数就可以用普通模式合并，能看出来曾经做过合并，包含作者和时间戳等信息，而fast forward合并就看不出来曾经做过合并。\n保存工作现场git stash\n查看工作现场git stash list\n恢复工作现场git stash pop\n丢弃一个没有合并过的分支git branch -D &lt;branchname&gt;\n\n查看远程库信息git remote -v\n\n在本地创建和远程分支对应的分支git checkout -b branch-name origin/branch-name，\n本地和远程分支的名称最好一致；\n建立本地分支和远程分支的关联git branch --set-upstream branch-name origin/branch-name；\n从本地推送分支git push origin branch-name\n如果推送失败，先用git pull抓取远程的新提交；\n从远程抓取分支git pull\n如果有冲突，要先处理冲突。\n标签tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。\n新建一个标签git tag &lt;tagname&gt;\n命令git tag &lt;tagname&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id。\n指定标签信息git tag -a &lt;tagname&gt; -m &lt;description&gt; &lt;branchname&gt; or commit_id\ngit tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息。\nPGP签名标签git tag -s &lt;tagname&gt; -m &lt;description&gt; &lt;branchname&gt; or commit_id\ngit tag -s &lt;tagname&gt; -m &quot;blablabla...&quot;可以用PGP签名标签。\n查看所有标签git tag\n推送一个本地标签git push origin &lt;tagname&gt;\n推送全部未推送过的本地标签git push origin --tags\n删除一个本地标签git tag -d &lt;tagname&gt;\n删除一个远程标签git push origin :refs/tags/&lt;tagname&gt;\n","tags":["Git"]},{"title":"Hello World","url":"/2020/11/03/hw/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","tags":["测试"]},{"title":"Termux安装Linux发行版的两种方法","url":"/2021/11/03/tr/","content":"最近一直疲于没有电脑，\n或者有了电脑但是版本过低的问题， \n同时也一直为Windows系统没有自带包管理器而困扰；\n想装一个Ubuntu的WSL，发现系统要求Windows10+，\n而学校卡顿无比的Windows7渣机也没法安装Vmware这样的高性能要求的虚拟机；\n转战到手机上，没有root过的Termux用起来又不爽；\n那么怎么办呢？\n此教程只适合没有或不常用电脑的人，还是首推大家用电脑的！\n方法一 PRoot其实Termux官方已经提供了安装几个Linux发行版的方法–PRoot，\n它的原理相当于创建了一个虚拟的root用户；\n(模拟器套虚拟机hahaha)\n安装方法如下:\n安装proot-distro\npkg install proot-distro\n或者\napt install proot-distro\n(过程需要代理)\n之后输入指令查看支持的发行版:\nproot-distro list\nArch，Fedora，Debian，Ubuntu等等，这些系统都是有的；\n随后，输入指令安装需要的发行版:\nproot-distro install &lt;版本名&gt; \n\n如安装Ubuntu，则:\nproot-distro install ubuntu\n\n安装完成后，输入指令进入ubuntu:\nproot-distro login ubuntu\n\n随后就可以发现用户已经改变至root用户了，\n且跟Ubuntu系统无异；\n若觉得每次输入指令麻烦，可以编写一个sh脚本:\nnano Ubuntu.sh //新建shell文件proot-distro login ubuntu //粘贴指令Ctrl O //保存Ctrl X //退出\n\n之后sh Ubuntu.sh即可一键进入。\n方法二 Github项目首先安装Python:\npkg install python\n\n运行此指令安装依赖:\npkg install proot git python -y\n\n安装程序并执行脚本:\ngit clone https://github.com/sqlsec/termux-install-linuxcd termux-install-linuxpython termux-linux-install.py\n\n\n如果你安装了Ubuntu，则运行如下指令:\ncd ~/Termux-Linux/Ubuntu //打开脚本所在文件夹sh start-ubuntu.sh //进入Ubuntu\n同理，更换名称即可(前提是你安装了才会有)\n\n\n我是听话的便当\nBye～\n","tags":["Termux","Linux"]},{"title":"Linux命令行","url":"/2021/11/06/linux/","content":"前言本文章会不断更新和完善。快捷键 Ctrl+F 进行搜索 \n公钥私钥\n\n\n命令\n说明\n\n\n\nssh-keygen -t rsa -C “邮箱地址”\n产生公钥私钥对\n\n\nssh-copy-id -i ~/.ssh/id_rsa.pub &#114;&#x6f;&#111;&#116;&#64;&#49;&#57;&#50;&#x2e;&#49;&#x36;&#x38;&#46;&#48;&#46;&#50;\n将本地机器的公钥复制到远程机器的root用户的authorized_keys文件中\n\n\nssh-keygen -p -f ~/.ssh/id_rsa\n添加或修改SSH-key的私钥密码\n\n\nssh-keygen -y -f ~/.ssh/id_rsa &gt; id_rsa.pub\n从私钥中生成公钥\n\n\nssh-keygen -R 192.168.2.8\n从known_hosts文件中删除公钥信息\n\n\n系统信息\n\n\n命令\n说明\n\n\n\narch\n显示机器的处理器架构\n\n\ncal 2016\n显示2016年的日历表\n\n\ncat /proc/cpuinfo\n查看CPU信息\n\n\ncat /proc/interrupts\n显示中断\n\n\ncat /proc/meminfo\n校验内存使用\n\n\ncat /proc/swaps\n显示哪些swap被使用\n\n\ncat /proc/version\n显示内核版本\n\n\ncat /proc/net/dev\n显示网络适配器及统计\n\n\ncat /proc/mounts\n显示已加载的文件系统\n\n\nclock -w\n将时间修改保存到BIOS\n\n\ndate\n显示系统日期\n\n\ndate 072308302016.00\n设置日期和时间 - 月日时分年.秒\n\n\ndmidecode -q\n显示硬件系统部件 - (SMBIOS / DMI)\n\n\nhdparm -i /dev/hda\n罗列一个磁盘的架构特性\n\n\nhdparm -tT /dev/sda\n在磁盘上执行测试性读取操作\n\n\nlspci -tv\n罗列 PCI 设备\n\n\nlsusb -tv\n显示 USB 设备\n\n\nuname -m\n显示机器的处理器架构\n\n\nuname -r\n显示正在使用的内核版本\n\n\n\n\n\n\n关机\n\n\n命令\n说明\n\n\n\ninit 0\n关闭系统\n\n\nlogout\n注销\n\n\nreboot\n重启\n\n\nshutdown -h now\n关闭系统\n\n\nshutdown -h 16:30 &amp;\n按预定时间关闭系统\n\n\nshutdown -c\n取消按预定时间关闭系统\n\n\nshutdown -r now\n重启\n\n\ntelinit 0\n关闭系统\n\n\n\n\n\n\n文件和目录\n\n\n命令\n说明\n\n\n\ncd /home\n进入 ‘/home’ 目录\n\n\ncd ..\n返回上一级目录\n\n\ncd ../..\n返回上两级目录\n\n\ncd\n进入个人的主目录\n\n\ncd ~user1\n进入个人的主目录\n\n\ncd -\n返回上次所在的目录\n\n\ncp file1 file2\n复制一个文件\n\n\ncp dir/* .\n复制一个目录下的所有文件到当前工作目录\n\n\ncp -a /tmp/dir1 .\n复制一个目录到当前工作目录\n\n\ncp -a dir1 dir2\n复制一个目录\n\n\ncp file file1\n将file复制为file1\n\n\niconv -l\n列出已知的编码\n\n\niconv -f fromEncoding -t toEncoding inputFile &gt; outputFile\n改变字符的编码\n\n\nfind . -maxdepth 1 -name *.jpg -print -exec convert\nbatch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick)\n\n\nln -s file1 lnk1\n创建一个指向文件或目录的软链接\n\n\nln file1 lnk1\n创建一个指向文件或目录的物理链接\n\n\nls\n查看目录中的文件\n\n\nls -F\n查看目录中的文件\n\n\nls -l\n显示文件和目录的详细资料\n\n\nls -a\n显示隐藏文件\n\n\nls *[0-9]*\n显示包含数字的文件名和目录名\n\n\nlstree\n显示文件和目录由根目录开始的树形结构\n\n\nmkdir dir1\n创建一个叫做 ‘dir1’ 的目录\n\n\nmkdir dir1 dir2\n同时创建两个目录\n\n\nmkdir -p /tmp/dir1/dir2\n创建一个目录树\n\n\nmv dir1 new_dir\n重命名/移动 一个目录\n\n\npwd\n显示工作路径\n\n\nrm -f file1\n删除一个叫做 ‘file1’ 的文件\n\n\nrm -rf dir1\n删除一个叫做 ‘dir1’ 的目录并同时删除其内容\n\n\nrm -rf dir1 dir2\n同时删除两个目录及它们的内容\n\n\nrmdir dir1\n删除一个叫做 ‘dir1’ 的目录\n\n\ntouch -t 1607230000 file1\n修改一个文件或目录的时间戳 - (YYMMDDhhmm)\n\n\ntree\n显示文件和目录由根目录开始的树形结构\n\n\n\n\n\n\n文件搜索\n\n\n命令\n说明\n\n\n\nfind / -name file1\n从 ‘/‘ 开始进入根文件系统搜索文件和目录\n\n\n# find / -user user1\n搜索属于用户 ‘user1’ 的文件和目录\n\n\n# find /home/user1 -name \\*.bin\n在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件\n\n\n# find /usr/bin -type f -atime +100\n搜索在过去100天内未被使用过的执行文件\n\n\n# find /usr/bin -type f -mtime -10\n搜索在10天内被创建或者修改过的文件\n\n\n# find / -name *.rpm -exec chmod 755 ‘{}‘ \\;\n搜索以 ‘.rpm’ 结尾的文件并定义其权限\n\n\n# find / -xdev -name \\*.rpm\n搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备\n\n\n# locate \\*.ps\n寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令\n\n\n# whereis halt\n显示一个二进制文件、源码或man的位置\n\n\n# which halt\n显示一个二进制文件或可执行文件的完整路径\n\n\n\n\n\n\n挂载一个文件系统\n\n\n命令\n说明\n\n\n\n# fuser -km /mnt/hda2\n当设备繁忙时强制卸载\n\n\n# mount /dev/hda2 /mnt/hda2\n挂载一个叫做hda2的盘 - 确保目录 ‘/mnt/hda2’ 已经存在\n\n\n# mount /dev/fd0 /mnt/floppy\n挂载一个软盘\n\n\n# mount /dev/cdrom /mnt/cdrom\n挂载一个cdrom或dvdrom\n\n\n# mount /dev/hdc /mnt/cdrecorder\n挂载一个cdrw或dvdrom\n\n\n# mount /dev/hdb /mnt/cdrecorder\n挂载一个cdrw或dvdrom\n\n\n# mount -o loop file.iso /mnt/cdrom\n挂载一个文件或ISO镜像文件\n\n\n# mount -t vfat /dev/hda5 /mnt/hda5\n挂载一个Windows FAT32文件系统\n\n\n# mount /dev/sda1 /mnt/usbdisk\n挂载一个U盘或闪存设备\n\n\n# mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share\n挂载一个windows网络共享\n\n\n# umount /dev/hda2\n卸载一个叫做hda2的盘 - 先从挂载点 ‘/mnt/hda2’ 退出\n\n\n# umount -n /mnt/hda2\n运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用\n\n\n\n\n\n\n磁盘空间\n\n\n命令\n说明\n\n\n\n# df -h\n显示已经挂载的分区列表\n\n\n# dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ &#124; sort -k1,1n\n以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统)\n\n\n# du -sh dir1\n估算目录 ‘dir1’ 已经使用的磁盘空间\n\n\n# du -sk * &#124; sort -rn\n以容量大小为依据依次显示文件和目录的大小\n\n\n# ls -lSr &#124; more\n以尺寸大小排列文件和目录\n\n\n# rpm -q -a --qf ‘%10{SIZE}t%{NAME}n’ &#124; sort -k1,1n\n以大小为依据依次显示已安装的rpm包所使用的空间 (centos, redhat, fedora类系统)\n\n\n\n\n\n\n用户和群组\n\n\n命令\n说明\n\n\n\n# chage -E 2016-12-31 user1\n设置用户口令的失效期限\n\n\n# groupadd [group]\n创建一个新用户组\n\n\n# groupdel [group]\n删除一个用户组\n\n\n# groupmod -n moon sun\n重命名一个用户组\n\n\n# grpck\n检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组\n\n\n# newgrp - [group]\n登陆进一个新的群组以改变新创建文件的预设群组\n\n\n# passwd\n修改口令\n\n\n# passwd user1\n修改一个用户的口令 (只允许root执行)\n\n\n# pwck\n检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户\n\n\n# useradd -c “User Linux” -g admin -d /home/user1 -s /bin/bash user1\n创建一个属于 “admin” 用户组的用户\n\n\n# useradd user1\n创建一个新用户\n\n\n# userdel -r user1\n删除一个用户 ( ‘-r’ 排除主目录)\n\n\n# usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1\n修改用户属性\n\n\n\n\n\n\n文件的权限\n\n\n命令\n说明\n\n\n\n# chgrp group1 file1\n改变文件的群组\n\n\n# chmod ugo+rwx directory1\n设置目录的所有人(u)、群组(g)以及其他人(o)以读(r)、写(w)和执行(x)的权限\n\n\n# chmod go-rwx directory1\n删除群组(g)与其他人(o)对目录的读写执行权限\n\n\n# chmod u+s /bin/file1\n设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限\n\n\n# chmod u-s /bin/file1\n禁用一个二进制文件的 SUID 位\n\n\n# chmod g+s /home/public\n设置一个目录的 SGID 位 - 类似SUID，不过这是针对目录的\n\n\n# chmod g-s /home/public\n禁用一个目录的 SGID 位\n\n\n# chmod o+t /home/public\n设置一个文件的 STIKY 位 - 只允许合法所有人删除文件\n\n\n# chmod o-t /home/public\n禁用一个目录的 STIKY 位\n\n\n# chown user1 file1\n改变一个文件的所有人属性\n\n\n# chown -R user1 directory1\n改变一个目录的所有人属性并同时改变改目录下所有文件的属性\n\n\n# chown user1:group1 file1\n改变一个文件的所有人和群组属性\n\n\n# find / -perm -u+s\n罗列一个系统中所有使用了SUID控制的文件\n\n\n# ls -lh\n显示权限\n\n\n# ls /tmp &#124; pr -T5 -W$COLUMNS\n将终端划分成5栏显示\n\n\n\n\n\n\n文件的特殊属性\n\n\n命令\n说明\n\n\n\n# chattr +a file1\n只允许以追加方式读写文件\n\n\n# chattr +c file1\n允许这个文件能被内核自动压缩/解压\n\n\n# chattr +d file1\n在进行文件系统备份时，dump程序将忽略这个文件\n\n\n# chattr +i file1\n设置成不可变的文件，不能被删除、修改、重命名或者链接\n\n\n# chattr +s file1\n允许一个文件被安全地删除\n\n\n# chattr +S file1\n一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘\n\n\n# chattr +u file1\n若文件被删除，系统会允许你在以后恢复这个被删除的文件\n\n\n# lsattr\n显示特殊的属性\n\n\n\n\n\n\n打包和压缩文件\n\n\n命令\n说明\n\n\n\n# bunzip2 file1.bz2\n解压一个叫做 ‘file1.bz2’的文件\n\n\n# bzip2 file1\n压缩一个叫做 ‘file1’ 的文件\n\n\n# gunzip file1.gz\n解压一个叫做 ‘file1.gz’的文件\n\n\n# gzip file1\n压缩一个叫做 ‘file1’的文件\n\n\n# gzip -9 file1\n最大程度压缩\n\n\n# rar a file1.rar test_file\n创建一个叫做 ‘file1.rar’ 的包\n\n\n# rar a file1.rar file1 file2 dir1\n同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’\n\n\n# rar x file1.rar\n解压rar包\n\n\n# tar -cvf archive.tar file1\n创建一个非压缩的 tarball\n\n\n# tar -cvf archive.tar file1 file2 dir1\n创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件\n\n\n# tar -tf archive.tar\n显示一个包中的内容\n\n\n# tar -xvf archive.tar\n释放一个包\n\n\n# tar -xvf archive.tar -C /tmp\n将压缩包释放到 /tmp目录下\n\n\n# tar -cvfj archive.tar.bz2 dir1\n创建一个bzip2格式的压缩包\n\n\n# tar -xvfj archive.tar.bz2\n解压一个bzip2格式的压缩包\n\n\n# tar -cvfz archive.tar.gz dir1\n创建一个gzip格式的压缩包\n\n\n# tar -xvfz archive.tar.gz\n解压一个gzip格式的压缩包\n\n\n# unrar x file1.rar\n解压rar包\n\n\n# unzip file1.zip\n解压一个zip格式压缩包\n\n\n# zip file1.zip file1\n创建一个zip格式的压缩包\n\n\n# zip -r file1.zip file1 file2 dir1\n将几个文件和目录同时压缩成一个zip格式的压缩包\n\n\n\n\n\n\nRPM包 (Fedora,RedHat and alike)\n\n\n命令\n说明\n\n\n\n# rpm -ivh [package.rpm]\n安装一个rpm包\n\n\n# rpm -ivh --nodeeps [package.rpm]\n安装一个rpm包而忽略依赖关系警告\n\n\n# rpm -U [package.rpm]\n更新一个rpm包但不改变其配置文件\n\n\n# rpm -F [package.rpm]\n更新一个确定已经安装的rpm包\n\n\n# rpm -e [package]\n删除一个rpm包\n\n\n# rpm -qa\n显示系统中所有已经安装的rpm包\n\n\n# rpm -qa &#124; grep httpd\n显示所有名称中包含 “httpd” 字样的rpm包\n\n\n# rpm -qi [package]\n获取一个已安装包的特殊信息\n\n\n# rpm -qg “System Environment/Daemons”\n显示一个组件的rpm包\n\n\n# rpm -ql [package]\n显示一个已经安装的rpm包提供的文件列表\n\n\n# rpm -qc [package]\n显示一个已经安装的rpm包提供的配置文件列表\n\n\n# rpm -q [package] --whatrequires\n显示与一个rpm包存在依赖关系的列表\n\n\n# rpm -q [package] --whatprovides\n显示一个rpm包所占的体积\n\n\n# rpm -q [package] --scripts\n显示在安装/删除期间所执行的脚本l\n\n\n# rpm -q [package] --changelog\n显示一个rpm包的修改历史\n\n\n# rpm -qf /etc/httpd/conf/httpd.conf\n确认所给的文件由哪个rpm包所提供\n\n\n# rpm -qp [package.rpm] -l\n显示由一个尚未安装的rpm包提供的文件列表\n\n\n# rpm --import /media/cdrom/RPM-GPG-KEY\n导入公钥数字证书\n\n\n# rpm --checksig [package.rpm]\n确认一个rpm包的完整性\n\n\n# rpm -qa gpg-pubkey\n确认已安装的所有rpm包的完整性\n\n\n# rpm -V [package]\n检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间\n\n\n# rpm -Va\n检查系统中所有已安装的rpm包- 小心使用\n\n\n# rpm -Vp [package.rpm]\n确认一个rpm包还未安装\n\n\n# rpm -ivh /usr/src/redhat/RPMS/`arch`/[package.rpm]\n从一个rpm源码安装一个构建好的包\n\n\n# rpm2cpio [package.rpm] &#124; cpio --extract --make-directories *bin*\n从一个rpm包运行可执行文件\n\n\n# rpmbuild --rebuild [package.src.rpm]\n从一个rpm源码构建一个 rpm 包\n\n\n\n\n\n\nYUM 软件工具 (Fedora,RedHat and alike)\n\n\n命令\n说明\n\n\n\n# yum -y install [package]\n下载并安装一个rpm包\n\n\n# yum localinstall [package.rpm]\n将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系\n\n\n# yum -y update\n更新当前系统中所有安装的rpm包\n\n\n# yum update [package]\n更新一个rpm包\n\n\n# yum remove [package]\n删除一个rpm包\n\n\n# yum list\n列出当前系统中安装的所有包\n\n\n# yum repolist\n显示可用的仓库\n\n\n# yum search [package]\n在rpm仓库中搜寻软件包\n\n\n# yum clean [package]\n清理rpm缓存删除下载的包\n\n\n# yum clean headers\n删除所有头文件\n\n\n# yum clean all\n删除所有缓存的包和头文件\n\n\n\n\n\n\nDEB 包 (Debian, Ubuntu and alike)\n\n\n命令\n说明\n\n\n\n# dpkg -i [package.deb]\n安装/更新一个 deb 包\n\n\n# dpkg -r [package]\n从系统删除一个 deb 包\n\n\n# dpkg -l\n显示系统中所有已经安装的 deb 包\n\n\n# dpkg -l &#124; grep httpd\n显示所有名称中包含 “httpd” 字样的deb包\n\n\n# dpkg -s [package]\n获得已经安装在系统中一个特殊包的信息\n\n\n# dpkg -L [package]\n显示系统中已经安装的一个deb包所提供的文件列表\n\n\n# dpkg --contents [package.deb]\n显示尚未安装的一个包所提供的文件列表\n\n\n# dpkg -S /bin/ping\n确认所给的文件由哪个deb包提供\n\n\n\n\n\n\nAPT 软件工具 (Debian, Ubuntu and alike)\n\n\n命令\n说明\n\n\n\n# apt-cache search [package]\n返回包含所要搜索字符串的软件包名称\n\n\n# apt-cdrom install [package]\n从光盘安装/更新一个 deb 包\n\n\n# apt-get install [package]\n安装/更新一个 deb 包\n\n\n# apt-get update\n升级列表中的软件包\n\n\n# apt-get upgrade\n升级所有已安装的软件\n\n\n# apt-get remove [package]\n从系统删除一个deb包\n\n\n# apt-get check\n确认依赖的软件仓库正确\n\n\n# apt-get clean\n从下载的软件包中清理缓存\n\n\n\n\n\n\nPacman 软件工具 (Arch, Frugalware and alike)\n\n\n命令\n说明\n\n\n\n# pacman -S name\n根据依赖关系安装名为“name“的软件包\n\n\n# pacman -R name\n删除软件包”name” 及其所以文件\n\n\n\n\n\n\n查看文件内容\n\n\n命令\n说明\n\n\n\n# cat file1\n从第一个字节开始正向查看文件的内容\n\n\n# head -2 file1\n查看一个文件的前两行\n\n\n# less file1\n类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作\n\n\n# more file1\n查看一个长文件的内容\n\n\n# tac file1\n从最后一行开始反向查看一个文件的内容\n\n\n# tail -2 file1\n查看一个文件的最后两行\n\n\n# tail -f /var/log/messages\n实时查看被添加到一个文件中的内容\n\n\n\n\n\n\n文本处理\n\n\n命令\n说明\n\n\n\n# cat example.txt &#124; awk ‘NR%2==1’\n删除example.txt文件中的所有偶数行\n\n\n# echo a b c &#124; awk ‘{print $1}‘\n查看一行第一栏\n\n\n# echo a b c &#124; awk ‘{print $1,$3}‘\n查看一行的第一和第三栏\n\n\n# cat -n file1\n标示文件的行数\n\n\n# comm -1 file1 file2\n比较两个文件的内容只删除 ‘file1’ 所包含的内容\n\n\n# comm -2 file1 file2\n比较两个文件的内容只删除 ‘file2’ 所包含的内容\n\n\n# comm -3 file1 file2\n比较两个文件的内容只删除两个文件共有的部分\n\n\n# diff file1 file2\n找出两个文件内容的不同处\n\n\n# grep Aug /var/log/messages\n在文件 ‘/var/log/messages’中查找关键词”Aug”\n\n\n# grep ^Aug /var/log/messages\n在文件 ‘/var/log/messages’中查找以”Aug”开始的词汇\n\n\n# grep [0-9] /var/log/messages\n选择 ‘/var/log/messages’ 文件中所有包含数字的行\n\n\n# grep Aug -R /var/log/*\n在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug”\n\n\n# paste file1 file2\n合并两个文件或两栏的内容\n\n\n# paste -d ‘+‘ file1 file2\n合并两个文件或两栏的内容，中间用”+“区分\n\n\n# sdiff file1 file2\n以对比的方式显示两个文件的不同\n\n\n# sed ‘s/string1/string2/g’ example.txt\n将example.txt文件中的 “string1” 替换成 “string2”\n\n\n# sed ‘/^$/d’ example.txt\n从example.txt文件中删除所有空白行\n\n\n# sed ‘/ *&#124;#/d; /^$/d’ example.txt\n去除文件example.txt中的注释与空行\n\n\n# sed -e ‘1d’ exampe.txt\n从文件example.txt 中排除第一行\n\n\n# sed -n ‘/string1/p’\n查看只包含词汇 “string1”的行\n\n\n# sed -e ‘s/ *$//‘ example.txt\n删除每一行最后的空白字符\n\n\n# sed -e ‘s/string1//g’ example.txt\n从文档中只删除词汇 “string1” 并保留剩余全部\n\n\n# sed -n ‘1,5p’ example.txt\n显示文件1至5行的内容\n\n\n# sed -n ‘5p;5q’ example.txt\n显示example.txt文件的第5行内容\n\n\n# sed -e ‘s/00*/0/g’ example.txt\n用单个零替换多个零\n\n\n# sort file1 file2\n排序两个文件的内容\n\n\n# sort file1 file2 &#124; uniq\n取出两个文件的并集(重复的行只保留一份)\n\n\n# sort file1 file2 &#124; uniq -u\n删除交集，留下其他的行\n\n\n# sort file1 file2 &#124; uniq -d\n取出两个文件的交集(只留下同时存在于两个文件中的文件)\n\n\n# echo ‘word’ &#124; tr ‘[:lower:]‘ ‘[:upper:]‘\n合并上下单元格内容\n\n\n\n\n\n\n字符设置和文件格式\n\n\n命令\n说明\n\n\n\n# dos2unix filedos.txt fileunix.txt\n将一个文本文件的格式从MSDOS转换成UNIX\n\n\n# recode ..HTML &lt; page.txt &gt; page.html\n将一个文本文件转换成html\n\n\n# recode -l &#124; more\n显示所有允许的转换格式\n\n\n# unix2dos fileunix.txt filedos.txt\n将一个文本文件的格式从UNIX转换成MSDOS\n\n\n\n\n\n\n文件系统分析\n\n\n命令\n说明\n\n\n\n# badblocks -v /dev/hda1\n检查磁盘hda1上的坏磁块\n\n\n# dosfsck /dev/hda1\n修复/检查hda1磁盘上dos文件系统的完整性\n\n\n# e2fsck /dev/hda1\n修复/检查hda1磁盘上ext2文件系统的完整性\n\n\n# e2fsck -j /dev/hda1\n修复/检查hda1磁盘上ext3文件系统的完整性\n\n\n# fsck /dev/hda1\n修复/检查hda1磁盘上linux文件系统的完整性\n\n\n# fsck.ext2 /dev/hda1\n修复/检查hda1磁盘上ext2文件系统的完整性\n\n\n# fsck.ext3 /dev/hda1\n修复/检查hda1磁盘上ext3文件系统的完整性\n\n\n# fsck.vfat /dev/hda1\n修复/检查hda1磁盘上fat文件系统的完整性\n\n\n# fsck.msdos /dev/hda1\n修复/检查hda1磁盘上dos文件系统的完整性\n\n\n\n\n\n\n初始化一个文件系统\n\n\n命令\n说明\n\n\n\n# fdformat -n /dev/fd0\n格式化一个软盘\n\n\n# mke2fs /dev/hda1\n在hda1分区创建一个linux ext2的文件系统\n\n\n# mke2fs -j /dev/hda1\n在hda1分区创建一个linux ext3(日志型)的文件系统\n\n\n# mkfs /dev/hda1\n在hda1分区创建一个文件系统\n\n\n# mkfs -t vfat 32 -F /dev/hda1\n创建一个 FAT32 文件系统\n\n\n# mkswap /dev/hda3\n创建一个swap文件系统\n\n\n\n\n\n\nSWAP 文件系统\n\n\n命令\n说明\n\n\n\n# mkswap /dev/hda3\n创建一个swap文件系统\n\n\n# swapon /dev/hda3\n启用一个新的swap文件系统\n\n\n# swapon /dev/hda2 /dev/hdb3\n启用两个swap分区\n\n\n\n\n\n\n备份\n\n\n命令\n说明\n\n\n\n# find /var/log -name ‘*.log’ &#124; tar cv --files-from=- &#124; bzip2 &gt; log.tar.bz2\n查找所有以 ‘.log’ 结尾的文件并做成一个bzip包\n\n\n# find /home/user1 -name ‘*.txt’ &#124; xargs cp -av --target-directory=/home/backup/ --parents\n从一个目录查找并复制所有以 ‘.txt’ 结尾的文件到另一个目录\n\n\n# dd bs=1M if=/dev/hda &#124; gzip &#124; ssh user@ip_addr ‘dd of=hda.gz’\n通过ssh在远程主机上执行一次备份本地磁盘的操作\n\n\n# dd if=/dev/sda of=/tmp/file1\n备份磁盘内容到一个文件\n\n\n# dd if=/dev/hda of=/dev/fd0 bs=512 count=1\n做一个将 MBR (Master Boot Record)内容复制到软盘的动作\n\n\n# dd if=/dev/fd0 of=/dev/hda bs=512 count=1\n从已经保存到软盘的备份中恢复MBR内容\n\n\n# dump -0aj -f /tmp/home0.bak /home\n制作一个 ‘/home’ 目录的完整备份\n\n\n# dump -1aj -f /tmp/home0.bak /home\n制作一个 ‘/home’ 目录的交互式备份\n\n\n# restore -if /tmp/home0.bak\n还原一个交互式备份\n\n\n# rsync -rogpav --delete /home /tmp\n同步两边的目录\n\n\n# rsync -rogpav -e ssh --delete /home ip_address:/tmp\n通过SSH通道rsync\n\n\n# rsync -az -e ssh --delete ip_addr:/home/public /home/local\n通过ssh和压缩将一个远程目录同步到本地目录\n\n\n# rsync -az -e ssh --delete /home/local ip_addr:/home/public\n通过ssh和压缩将本地目录同步到远程目录\n\n\n# tar -Puf backup.tar /home/user\n执行一次对 ‘/home/user’ 目录的交互式备份操作\n\n\n# ( cd /tmp/local/ &amp;&amp; tar c . ) &#124; ssh -C user@ip_addr ‘cd /home/share/ &amp;&amp; tar x -p’\n通过ssh在远程目录中复制一个目录内容\n\n\n# ( tar c /home ) &#124; ssh -C user@ip_addr ‘cd /home/backup-home &amp;&amp; tar x -p’\n通过ssh在远程目录中复制一个本地目录\n\n\n# tar cf - . &#124; (cd /tmp/backup ; tar xf - )\n本地将一个目录复制到另一个地方，保留原有权限及链接\n\n\n\n\n\n\n光盘\n\n\n命令\n说明\n\n\n\n# cd-paranoia -B\n从一个CD光盘转录音轨到 wav 文件中\n\n\n# cd-paranoia --\n从一个CD光盘转录音轨到 wav 文件中（参数-3）\n\n\n# cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force\n清空一个可复写的光盘内容\n\n\n# cdrecord -v dev=/dev/cdrom cd.iso\n刻录一个ISO镜像文件\n\n\n# gzip -dc cd_iso.gz &#124; cdrecord dev=/dev/cdrom -\n刻录一个压缩了的ISO镜像文件\n\n\n# cdrecord --scanbus\n扫描总线以识别scsi通道\n\n\n# dd if=/dev/hdc &#124; md5sum\n校验一个设备的md5sum编码，例如一张 CD\n\n\n# mkisofs /dev/cdrom &gt; cd.iso\n在磁盘上创建一个光盘的iso镜像文件\n\n\n# mkisofs /dev/cdrom &#124; gzip &gt; cd_iso.gz\n在磁盘上创建一个压缩了的光盘iso镜像文件\n\n\n# mkisofs -J -allow-leading-dots -R -V\n创建一个目录的iso镜像文件\n\n\n# mount -o loop cd.iso /mnt/iso\n挂载一个ISO镜像文件\n\n\n\n\n\n\n网络 (LAN / WiFi)\n\n\n命令\n说明\n\n\n\n# dhclient eth0\n以dhcp模式启用 ‘eth0’ 网络设备\n\n\n# ethtool eth0\n显示网卡 ‘eth0’ 的流量统计\n\n\n# host www.example.com\n查找主机名以解析名称与IP地址及镜像\n\n\n# hostname\n显示主机名\n\n\n# ifconfig eth0\n显示一个以太网卡的配置\n\n\n# ifconfig eth0 192.168.1.1 netmask 255.255.255.0\n控制IP地址\n\n\n# ifconfig eth0 promisc\n设置 ‘eth0’ 成混杂模式以嗅探数据包 (sniffing)\n\n\n# ifdown eth0\n禁用一个 ‘eth0’ 网络设备\n\n\n# ifup eth0\n启用一个 ‘eth0’ 网络设备\n\n\n# ip link show\n显示所有网络设备的连接状态\n\n\n# iwconfig eth1\n显示一个无线网卡的配置\n\n\n# iwlist scan\n显示无线网络\n\n\n# mii-tool eth0\n显示 ‘eth0’的连接状态\n\n\n# netstat -tup\n显示所有启用的网络连接和它们的 PID\n\n\n# netstat -tupl\n显示系统中所有监听的网络服务和它们的 PID\n\n\n# netstat -rn\n显示路由表，类似于“route -n”命令\n\n\n# nslookup www.example.com\n查找主机名以解析名称与IP地址及镜像\n\n\n# route -n\n显示路由表\n\n\n# route add -net 0/0 gw IP_Gateway\n控制预设网关\n\n\n# route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1\n控制通向网络 ‘192.168.0.0/16’ 的静态路由\n\n\n# route del 0/0 gw IP_gateway\n删除静态路由\n\n\n# echo “1” &gt; /proc/sys/net/ipv4/ip_forward\n激活IP转发\n\n\n# tcpdump tcp port 80\n显示所有 HTTP回环\n\n\n# whois www.example.com\n在 Whois 数据库中查找\n\n\n\n\n\n\nMicrosoft windows 网络 (samba)\n\n\n命令\n说明\n\n\n\n# mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share\n挂载一个windows网络共享\n\n\n# nbtscan ip_addr\nnetbios名解析\n\n\n# nmblookup -A ip_addr\nnetbios名解析\n\n\n# smbclient -L ip_addr/hostname\n显示一台windows主机的远程共享\n\n\n# smbget -Rr smb://ip_addr/share\n像wget一样能够通过smb从一台windows主机上下载文件\n\n\n\n\n\n\nIPTABLES (firewall)\n\n\n命令\n说明\n\n\n\n# iptables -t filter -L\n显示过滤表的所有链路\n\n\n# iptables -t nat -L\n显示nat表的所有链路\n\n\n# iptables -t filter -F\n以过滤表为依据清理所有规则\n\n\n# iptables -t nat -F\n以nat表为依据清理所有规则\n\n\n# iptables -t filter -X\n删除所有由用户创建的链路\n\n\n# iptables -t filter -A INPUT -p tcp --dport telnet -j ACCEPT\n允许telnet接入\n\n\n# iptables -t filter -A OUTPUT -p tcp --dport http -j DROP\n阻止 HTTP 连出\n\n\n# iptables -t filter -A FORWARD -p tcp --dport pop3 -j ACCEPT\n允许转发链路上的 POP3 连接\n\n\n# iptables -t filter -A INPUT -j LOG --log-prefix\n记录所有链路中被查封的包\n\n\n# iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE\n设置一个 PAT (端口地址转换) 在 eth0 掩盖发出包\n\n\n# iptables -t nat -A PREROUTING -d 192.168.0.1 -p tcp -m tcp --dport 22 -j DNAT --to-destination 10.0.0.2:22\n将发往一个主机地址的包转向到其他主机\n\n\n\n\n\n\n监视和调试\n\n\n命令\n说明\n\n\n\n# free -m\n以兆为单位罗列RAM状态\n\n\n# kill -9 process_id\n强行关闭进程并结束它\n\n\n# kill -1 process_id\n强制一个进程重载其配置\n\n\n# last reboot\n显示重启历史\n\n\n# lsmod\n罗列装载的内核模块\n\n\n# lsof -p process_id\n罗列一个由进程打开的文件列表\n\n\n# lsof /home/user1\n罗列所给系统路径中所打开的文件的列表\n\n\n# ps -eafw\n罗列linux任务\n\n\n# ps -e -o pid,args --forest\n以分级的方式罗列linux任务\n\n\n# pstree\n以树状图显示程序\n\n\n# smartctl -A /dev/hda\n通过启用SMART监控硬盘设备的可靠性\n\n\n# smartctl -i /dev/hda\n检查一个硬盘设备的 SMART 是否启用\n\n\n# strace -c ls &gt;/dev/null\n罗列系统 calls made并用一个进程接收\n\n\n# strace -f -e open ls &gt;/dev/null\n罗列库调用\n\n\n# tail /var/log/dmesg\n显示内核引导过程中的内部事件\n\n\n# tail /var/log/messages\n显示系统事件\n\n\n# top\n罗列使用CPU资源最多的linux任务\n\n\n# watch -n1 ‘cat /proc/interrupts’\n罗列实时中断\n\n\n\n\n\n\n其他\n\n\n命令\n说明\n\n\n\n# alias hh=’history’\n为命令history(历史)设置一个别名\n\n\n# apropos ...keyword\n罗列一个包括程序关键词的命令列表，当你仅知晓程序是干什么，而又记不得命令时特别有用\n\n\n# chsh\n改变shell命令\n\n\n# chsh --list-shells\n用于了解你是否必须远程连接到别的机器的不错的命令\n\n\n# gpg -c file1\n用GNU Privacy Guard加密一个文件\n\n\n# gpg file1.gpg\n用GNU Privacy Guard解密一个文件\n\n\n# ldd /usr/bin/ssh\n显示ssh程序所依赖的共享库\n\n\n# man ping\n罗列在线手册页（例如ping 命令）\n\n\n# mkbootdisk --device /dev/fd0 `uname -r`\n创建一个引导软盘\n\n\n# wget -r www.example.com\n下载一个完整的web站点\n\n\n# wget -c www.example.com/file.iso\n以支持断点续传的方式下载一个文件\n\n\n# echo ‘wget -c www.example.com/files.iso’ &#124; at 09:00\n在任何给定的时间开始一次下载\n\n\n# whatis ...keyword\n罗列该程序功能的说明\n\n\n# who -a\n显示谁正登录在线，并打印出：系统最后引导的时间，关机进程，系统登录进程以及由init启动的进程，当前运行级和最后一次系统时钟的变化\n\n\n\n\n\n\n完毕！\n\n\n\n\n\n\n\n【参考资料】\n\n\n\nhttp://www.linuxguide.it\n\n\n\nhttp://man.linuxde.net\n\n\n\n\n\n\n\n","tags":["Linux"]}]